// src/features/deck-management/hooks/useDeckEditor.ts

import { useEffect, useState } from 'react';
import { useDeckStore } from '../../../stores/deckStore';
import { deckService } from '../../../services/deck-logic/deckService';
import { useCardPoolStore } from '../../../stores/cardPoolStore';
import { useShallow } from 'zustand/react/shallow';
import { useNavigate } from '@tanstack/react-router'; 
// import type { Deck } from '../../../models/deck';

/**
 * ãƒ‡ãƒƒã‚­ç·¨é›†ç”»é¢ã®ãƒ­ã‚¸ãƒƒã‚¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰ã€ä¿å­˜å‡¦ç†ã‚’çµ±åˆã™ã‚‹ Hook
 * @param deckId - ç·¨é›†å¯¾è±¡ã®ãƒ‡ãƒƒã‚­ID (æ–°è¦ä½œæˆã®å ´åˆã¯ 'create' ãªã©)
 */
export const useDeckEditor = (deckId: string) => {
    const [isLoading, setIsLoading] = useState(true);
    const [saveMessage, setSaveMessage] = useState<string | null>(null);
    const navigate = useNavigate(); 

    // ğŸ’¡ Zustandã‚¹ãƒˆã‚¢ã‹ã‚‰ç·¨é›†ä¸­ã®ãƒ‡ãƒƒã‚­ãƒ‡ãƒ¼ã‚¿ã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—
    const {
        currentDeck,
        loadDeckForEdit,
        // ğŸš¨ ä¿®æ­£1: startNewDeck ã‚’å‰Šé™¤
        updateDeckInfo,
        saveDeck,
        deleteDeck: deleteDeckFromStore 
    } = useDeckStore(useShallow(state => ({
        currentDeck: state.currentDeck,
        loadDeckForEdit: state.loadDeckForEdit,
        // ğŸš¨ ä¿®æ­£1: startNewDeck ã‚’å‰Šé™¤
        updateDeckInfo: state.updateDeckInfo,
        saveDeck: state.saveDeck,
        deleteDeck: state.deleteDeck,
    })));
    
    // ğŸ’¡ ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã‚¹ãƒˆã‚¢ã‹ã‚‰æ‰€æœ‰ã‚«ãƒ¼ãƒ‰è³‡ç”£ã‚’å–å¾—
    const ownedCards = useCardPoolStore(state => state.ownedCards);

    // 1. åˆæœŸãƒ­ãƒ¼ãƒ‰ / ãƒ‡ãƒƒã‚­åˆ‡ã‚Šæ›¿ãˆãƒ­ã‚¸ãƒƒã‚¯
    useEffect(() => {
        setIsLoading(true);

        if (deckId === 'create') {
            // æ–°è¦ä½œæˆãƒ¢ãƒ¼ãƒ‰
            // ã‚¹ãƒˆã‚¢å´ã§åˆæœŸåŒ–ã•ã‚ŒãŸç©ºã®ãƒ‡ãƒƒã‚­ãŒ currentDeck ã«å…¥ã£ã¦ã„ã‚‹ã¯ãš
            console.log("Starting new deck creation mode...");
            // startNewDeck(); // ğŸ’¡ startNewDeck ãŒãªããªã‚Œã°ã€storeå´ã§ currentDeck ã‚’åˆæœŸå€¤ã«ä¿ã¤å¿…è¦ãŒã‚ã‚‹
            setIsLoading(false);
            return;
        }

        if (deckId) {
            // æ—¢å­˜ãƒ‡ãƒƒã‚­ã®ãƒ­ãƒ¼ãƒ‰
            deckService.getDeckById(deckId).then(existingDeck => {
                if (existingDeck) {
                    // ğŸš¨ ä¿®æ­£2: loadDeckForEditã¯DeckId (string) ã‚’å¼•æ•°ã«å–ã‚‹ã‚ˆã†ã«ä¿®æ­£
                    loadDeckForEdit(existingDeck.deckId); 
                    console.log(`Deck ${existingDeck.name} loaded.`);
                } else {
                    alert(`ID: ${deckId} ã®ãƒ‡ãƒƒã‚­ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
                    // è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ã€ãƒªã‚¹ãƒˆç”»é¢ã«æˆ»ã™
                    navigate({ to: '/user/decks' });
                }
                setIsLoading(false);
            });
        }
        
        // ğŸš¨ ä¾å­˜é…åˆ—ã‹ã‚‰ startNewDeck ã‚’å‰Šé™¤
    }, [deckId, loadDeckForEdit, navigate]);

    // 2. ãƒ‡ãƒƒã‚­ä¿å­˜ãƒ­ã‚¸ãƒƒã‚¯
    const handleSaveDeck = async () => {
        if (!currentDeck.name.trim()) {
            alert('ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
            return;
        }

        try {
            await saveDeck(); // ğŸ’¡ storeã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‘¼ã³å‡ºã—
            setSaveMessage('ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼');
            
            // ğŸ’¡ æ–°è¦ä½œæˆå¾Œã€URLã‚’å®Ÿéš›ã®IDã«å¤‰æ›´
            if (deckId === 'create') {
                 // æˆåŠŸæ™‚ã«æ–°ã—ã„IDã§URLã‚’ç½®ãæ›ãˆã‚‹
                 navigate({ to: '/user/decks/$deckId', params: { deckId: currentDeck.deckId }, replace: true });
            }
            setTimeout(() => setSaveMessage(null), 3000);
        } catch (error) {
            setSaveMessage('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            console.error('Save failed:', error);
        }
    };
    
    // 3. ãƒ‡ãƒƒã‚­å‰Šé™¤ãƒ­ã‚¸ãƒƒã‚¯
    const handleDeleteDeck = async () => {
        if (!window.confirm(`ãƒ‡ãƒƒã‚­ã€Œ${currentDeck.name}ã€ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
            return;
        }
        try {
            await deckService.deleteDeck(currentDeck.deckId); // ğŸ’¡ ã‚µãƒ¼ãƒ“ã‚¹ã‹ã‚‰å‰Šé™¤
            
            // ã‚¹ãƒˆã‚¢ã®ãƒªã‚»ãƒƒãƒˆã¨ãƒªã‚¹ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
            deleteDeckFromStore(currentDeck.deckId); // ğŸ’¡ ã‚¹ãƒˆã‚¢ã®ç·¨é›†çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            navigate({ to: '/user/decks' });
        } catch (error) {
            alert('ãƒ‡ãƒƒã‚­ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            console.error(error);
        }
    };

    // 4. (ãã®ä»–ã®ãƒ­ã‚¸ãƒƒã‚¯: ã‚«ãƒ¼ãƒ‰æ•°è¨ˆç®—ã€æ‰€æœ‰æ•°ãƒã‚§ãƒƒã‚¯ãªã©)
    // ...

    return {
        isLoading,
        saveMessage,
        currentDeck,
        ownedCards, // ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã¨ã®æ¯”è¼ƒã«ä½¿ç”¨
        handleSaveDeck,
        handleDeleteDeck,
        updateDeckInfo,
        // ... (ãã®ä»–ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™)
    };
};