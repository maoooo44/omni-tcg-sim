// src/features/pack-opening/hooks/usePackOpenerData.ts (エラー解消版 全文)

import { useState, useEffect } from 'react';

import type { Pack } from '../../../models/pack'; //

import { usePackStore } from '../../../stores/packStore'; //
import { simulatePackOpening } from '../../../services/pack-logic/simulationUtils'; //
import { useCardPoolStore } from '../../../stores/cardPoolStore'; //
import { useCurrencyStore } from '../../../stores/currencyStore'; //
import { useShallow } from 'zustand/react/shallow'; //

// 警告ロジック対応のため、新しいシミュレーション結果の型を仮定
interface SimulationResult {
    results: { cardId: string, count: number }[];
    simulationWarning: string | null;
}

export const usePackOpenerData = (preselectedPackId?: string) => { 

    // packs は Pack[] 型 [4, 5]
    const packs = usePackStore(state => state.packs);
    const isLoading = packs.length === 0;

    // 💡 修正1: selectedPack の型を Pack | null に明示
    const [selectedPack, setSelectedPack] = useState<Pack | null>(null);
    const [lastOpenedResults, setLastOpenedResults] = useState<{ cardId: string, count: number }[] | null>(null);
    
    // 💡 修正2: エラー/警告メッセージの状態に型を明示
    const [purchaseError, setPurchaseError] = useState<string | null>(null); 
    const [simulationWarning, setSimulationWarning] = useState<string | null>(null); 

    const addCardsToPool = useCardPoolStore(state => state.addCards); //

    const { coins, spendCoins } = useCurrencyStore( //
        useShallow(state => ({
            coins: state.coins,
            spendCoins: state.spendCoins,
        }))
    );

    // 💡 修正3: 初期パック選択ロジックを修正し、Pack[] の代入を避ける
useEffect(() => { 
    if (packs.length > 0 && selectedPack === null) {
        
        // 1. URLパラメータに一致するパックを探す (Pack | undefined)
        let packToSelect: Pack | undefined = packs.find(p => p.packId === preselectedPackId);
        
        // 2. 見つからなかった場合、最初のパック (Pack) を選択
        // 🚨 TS2740 エラー解消のための修正: 配列全体 packs ではなく、最初の要素 packs[0] を使用する。
        if (!packToSelect) {
            packToSelect = packs[0]; // <--- 修正箇所
        }
        
        // 3. 選択状態を更新
        if (packToSelect) {
            setSelectedPack(packToSelect); 
        }
    }
}, [packs, preselectedPackId, selectedPack]); 

    // パック開封ロジック (handleOpenPack) は省略（前回の修正を維持）
    const handleOpenPack = async () => { 
        // ... (省略: パック開封ロジック)
        if (!selectedPack) {
            setPurchaseError('パックが選択されていません。');
            return;
        }

        setPurchaseError(null);
        setLastOpenedResults(null);
        setSimulationWarning(null);

        const packPrice = selectedPack.price || 0;
        const purchaseSuccessful = await spendCoins(packPrice);

        if (!purchaseSuccessful) {
            setPurchaseError(`所持コインが不足しています。（必要: ${packPrice} / 所持: ${coins}）`); 
            return;
        }

        try {
            const simulationResult = simulatePackOpening(selectedPack) as unknown as SimulationResult;
            const results = simulationResult.results;
            const warning = simulationResult.simulationWarning;

            if (warning) {
                setSimulationWarning(warning);
            }

            const cardsToAdd = results.map(r => ({
                cardId: r.cardId,
                count: r.count,
                packId: selectedPack.packId 
            }));

            await addCardsToPool(cardsToAdd);

            setLastOpenedResults(results); 

        } catch (error) {
            console.error('パック開封中にエラーが発生しました:', error); 
            setPurchaseError('パック抽選中に致命的なエラーが発生しました。'); 
        }
    };


    // --- 戻り値 ---
    return {
        packs, 
        selectedPack,
        setSelectedPack: (packId: string) => { 
            const pack = packs.find(p => p.packId === packId);
            setSelectedPack(pack || null); 
        },
        isLoading,
        handleOpenPack,
        lastOpenedResults,
        coins,
        purchaseError,
        simulationWarning, // 警告状態を公開
    };
};