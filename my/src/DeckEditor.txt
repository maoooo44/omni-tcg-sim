// src/features/deck-management/DeckEditor.tsx

import React, { useMemo, useState } from 'react';
import { 
    Box, Typography, Button, Alert, Grid, Paper, 
    TextField, IconButton, Divider, List, ListItem, ListItemText,
    InputAdornment, Avatar, // Tooltip 
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import SaveIcon from '@mui/icons-material/Save';
import DeleteIcon from '@mui/icons-material/Delete';
import SearchIcon from '@mui/icons-material/Search';

import type { Deck } from '../../models/deck';
import { useCardStore } from '../../stores/cardStore'; 
import { useShallow } from 'zustand/react/shallow';
import { useCardPoolStore } from '../../stores/cardPoolStore'; 

// 💡 DeckEditorに必要なPropsを定義
interface DeckEditorProps {
    deck: Deck;
    addCard: (cardId: string, deckType: 'mainDeck' | 'sideDeck' | 'extraDeck') => void;
    removeCard: (cardId: string, deckType: 'mainDeck' | 'sideDeck' | 'extraDeck') => void;
    onSave: () => Promise<void>;
    onDelete: () => Promise<void>;
    updateDeckInfo: (info: Partial<Omit<Deck, 'mainDeck' | 'sideDeck' | 'extraDeck'>>) => void;
    saveMessage: string | null;
}

// 補助関数: デッキの総枚数を計算
const calculateTotalCards = (deckMap: Map<string, number>): number => {
    return Array.from(deckMap.values()).reduce((sum, count) => sum + count, 0);
};

// 補助関数: カードの所持情報を取得
interface CardOwnership {
    ownedCount: number;
    requiredCount: number;
    missingCount: number;
    isOwned: boolean;
    isMissing: boolean;
}

const getCardOwnership = (cardId: string, requiredCount: number, ownedCardsMap: Map<string, number>): CardOwnership => {
    const ownedCount = ownedCardsMap.get(cardId) || 0;
    const missingCount = Math.max(0, requiredCount - ownedCount);
    
    return {
        ownedCount,
        requiredCount,
        missingCount,
        isOwned: ownedCount > 0,
        isMissing: missingCount > 0,
    };
};

const DeckEditor: React.FC<DeckEditorProps> = ({
    deck,
    addCard,
    removeCard,
    onSave,
    onDelete,
    updateDeckInfo,
    saveMessage,
}) => {
    const { cards: allCards } = useCardStore(useShallow(state => ({ cards: state.cards })));
    const allCardsMap = useMemo(() => new Map(allCards.map(c => [c.cardId, c])), [allCards]);
    
    const ownedCards = useCardPoolStore(useShallow(state => state.ownedCards)); 
    
    const [searchTerm, setSearchTerm] = useState('');

    // デッキ情報用のState (Storeで管理されるが、ローカルで一時的に保持)
    const [deckName, setDeckName] = useState(deck.name);
    const [deckDescription, setDeckDescription] = useState(deck.description);
    
    // Deck Name, Descriptionの変更を即座にStoreに反映
    React.useEffect(() => {
        setDeckName(deck.name);
        setDeckDescription(deck.description);
    }, [deck.name, deck.description]);

    const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setDeckName(e.target.value);
        updateDeckInfo({ name: e.target.value });
    };

    const handleDescriptionChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        setDeckDescription(e.target.value);
        updateDeckInfo({ description: e.target.value });
    };

    // 検索フィルタリングされたカードプール
    const filteredCardPool = useMemo(() => {
        const term = searchTerm.toLowerCase();
        if (!term) return allCards;
        
        return allCards.filter(card => 
            card.name.toLowerCase().includes(term) ||
            card.rarity.toLowerCase().includes(term) ||
            card.packId.toLowerCase().includes(term)
        );
    }, [allCards, searchTerm]);


    // 💡 メインデッキ/サイドデッキの表示部分 (レンダリング関数)
    const renderDeckList = (deckMap: Map<string, number>, title: string, deckType: 'mainDeck' | 'sideDeck' | 'extraDeck') => (
        <Box sx={{ mb: 3 }}>
            <Typography variant="h6" gutterBottom>
                {title} ({calculateTotalCards(deckMap)} 枚)
            </Typography>
            <List dense sx={{ border: '1px solid #ccc', borderRadius: 1, maxHeight: 350, overflowY: 'auto' }}>
                {Array.from(deckMap.entries()).map(([cardId, count]) => {
                    const cardData = allCardsMap.get(cardId);
                    if (!cardData) return null;

                    const { missingCount, ownedCount, isMissing } = getCardOwnership(cardId, count, ownedCards);

                    return (
                        <ListItem 
                            key={cardId} 
                            secondaryAction={
                                <Box>
                                    <IconButton size="small" onClick={() => addCard(cardId, deckType)}>
                                        <AddIcon fontSize="inherit" />
                                    </IconButton>
                                    <IconButton size="small" onClick={() => removeCard(cardId, deckType)} disabled={count <= 0}>
                                        <RemoveIcon fontSize="inherit" />
                                    </IconButton>
                                </Box>
                            }
                            sx={{ 
                                bgcolor: isMissing ? '#fff0f0' : 'background.paper', // 💡 未所有カードは背景色変更
                                borderBottom: '1px solid #eee',
                            }}
                        >
                            <Avatar 
                                src={cardData.imageUrl} 
                                variant="rounded" 
                                sx={{ 
                                    width: 30, height: 42, mr: 1, 
                                    filter: isMissing ? 'grayscale(100%)' : 'none' // 💡 未所有カードはグレーアウト
                                }} 
                            />
                            <ListItemText
                                primary={
                                    <Box component="span" sx={{ display: 'flex', alignItems: 'center' }}>
                                        <Typography component="span" sx={{ mr: 1, fontWeight: 'bold' }}>x {count}</Typography>
                                        <Typography component="span" color={isMissing ? 'error' : 'text.primary'}>
                                            {cardData.name}
                                        </Typography>
                                    </Box>
                                }
                                secondary={
                                    isMissing ? (
                                        <Typography variant="caption" color="error" sx={{ fontWeight: 'bold' }}>
                                            🚨 不足 {missingCount} 枚 (所持: {ownedCount})
                                        </Typography>
                                    ) : (
                                        cardData.rarity
                                    )
                                }
                            />
                        </ListItem>
                    );
                })}
                {deckMap.size === 0 && (
                    <ListItem>
                        <ListItemText secondary="このデッキゾーンにはカードがありません。" />
                    </ListItem>
                )}
            </List>
        </Box>
    );


    return (
        <Box sx={{ p: 2 }}>
            <Typography variant="h4" gutterBottom>
                デッキ編集: {deck.name}
            </Typography>
            <Divider sx={{ mb: 2 }} />
            
            {/* 💡 警告メッセージのレンダリング */}
            {deck.hasUnownedCards && (
                <Alert severity="error" sx={{ mb: 2 }}>
                    ⚠️ **警告:** このデッキには、あなたが**所有数より多く**指定している、または**所有していないカード**が含まれています。
                </Alert>
            )}
            
            {/* 💡 保存メッセージ */}
            {saveMessage && (
                <Alert severity="success" sx={{ mb: 2 }}>
                    {saveMessage}
                </Alert>
            )}

            <Grid container spacing={3}>
                {/* 1. デッキ情報とカード検索 (左側) */}
                <Grid size={{ xs: 12, md: 4 }}>
                    <Paper elevation={3} sx={{ p: 2, mb: 3 }}>
                        <Typography variant="h6" gutterBottom>デッキ情報</Typography>
                        <TextField
                            label="デッキ名"
                            fullWidth
                            value={deckName}
                            onChange={handleNameChange}
                            margin="normal"
                        />
                        <TextField
                            label="説明"
                            fullWidth
                            multiline
                            rows={3}
                            value={deckDescription}
                            onChange={handleDescriptionChange}
                            margin="normal"
                        />
                        <Box sx={{ mt: 2, display: 'flex', justifyContent: 'space-between' }}>
                            <Button variant="contained" onClick={onSave} startIcon={<SaveIcon />}>
                                デッキを保存
                            </Button>
                            <Button variant="outlined" color="error" onClick={onDelete} startIcon={<DeleteIcon />}>
                                デッキ削除
                            </Button>
                        </Box>
                    </Paper>

                    {/* カードプール検索と追加 */}
                    <Paper elevation={3} sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>カードプールから追加</Typography>
                        <TextField
                            label="カード名 / レアリティで検索"
                            fullWidth
                            size="small"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            InputProps={{ startAdornment: <InputAdornment position="start"><SearchIcon /></InputAdornment> }}
                            sx={{ mb: 2 }}
                        />
                         
                         {/* 検索結果リスト */}
                         <List dense sx={{ maxHeight: 300, overflow: 'auto', border: '1px solid #ccc', borderRadius: 1 }}>
                            {filteredCardPool.map(card => {
                                const { isOwned } = getCardOwnership(card.cardId, 1, ownedCards);
                                
                                return (
                                    <ListItem 
                                        key={card.cardId}
                                        secondaryAction={
                                            <Button size="small" variant="contained" onClick={() => addCard(card.cardId, 'mainDeck')}>
                                                追加
                                            </Button>
                                        }
                                    >
                                        <Avatar 
                                            src={card.imageUrl} 
                                            variant="rounded" 
                                            sx={{ 
                                                width: 30, height: 42, mr: 1, 
                                                filter: isOwned ? 'none' : 'grayscale(100%)' // 💡 未所持はグレー
                                            }} 
                                        />
                                        <ListItemText
                                            primary={card.name}
                                            secondary={card.rarity + (isOwned ? '' : ' (未所持)')}
                                        />
                                    </ListItem>
                                );
                            })}
                         </List>
                         {filteredCardPool.length === 0 && <Alert severity="warning" sx={{ mt: 1 }}>カードが見つかりません。</Alert>}
                    </Paper>
                </Grid>

                {/* 2. デッキカードリスト (右側) */}
                <Grid size={{ xs: 12, md: 8 }}>
                    <Paper elevation={3} sx={{ p: 2 }}>
                        {renderDeckList(deck.mainDeck, 'メインデッキ', 'mainDeck')}
                        <Divider sx={{ my: 2 }} />
                        {renderDeckList(deck.sideDeck, 'サイドデッキ', 'sideDeck')}
                        <Divider sx={{ my: 2 }} />
                        {renderDeckList(deck.extraDeck, 'エクストラデッキ', 'extraDeck')}
                    </Paper>
                </Grid>
            </Grid>
        </Box>
    );
};

export default DeckEditor;