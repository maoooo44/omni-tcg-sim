// src/features/deck-management/DeckEditor.tsx

import React, { useMemo, useState } from 'react';
import { 
    Box, Typography, Button, Alert, Grid, Paper, 
    TextField, IconButton, Divider, List, ListItem, ListItemText,
    InputAdornment, Avatar, // Tooltip 
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import SaveIcon from '@mui/icons-material/Save';
import DeleteIcon from '@mui/icons-material/Delete';
import SearchIcon from '@mui/icons-material/Search';

import type { Deck } from '../../models/deck';
import { useCardStore } from '../../stores/cardStore'; 
import { useShallow } from 'zustand/react/shallow';
import { useCardPoolStore } from '../../stores/cardPoolStore'; 

// ğŸ’¡ DeckEditorã«å¿…è¦ãªPropsã‚’å®šç¾©
interface DeckEditorProps {
    deck: Deck;
    addCard: (cardId: string, deckType: 'mainDeck' | 'sideDeck' | 'extraDeck') => void;
    removeCard: (cardId: string, deckType: 'mainDeck' | 'sideDeck' | 'extraDeck') => void;
    onSave: () => Promise<void>;
    onDelete: () => Promise<void>;
    updateDeckInfo: (info: Partial<Omit<Deck, 'mainDeck' | 'sideDeck' | 'extraDeck'>>) => void;
    saveMessage: string | null;
}

// è£œåŠ©é–¢æ•°: ãƒ‡ãƒƒã‚­ã®ç·æšæ•°ã‚’è¨ˆç®—
const calculateTotalCards = (deckMap: Map<string, number>): number => {
    return Array.from(deckMap.values()).reduce((sum, count) => sum + count, 0);
};

// è£œåŠ©é–¢æ•°: ã‚«ãƒ¼ãƒ‰ã®æ‰€æŒæƒ…å ±ã‚’å–å¾—
interface CardOwnership {
    ownedCount: number;
    requiredCount: number;
    missingCount: number;
    isOwned: boolean;
    isMissing: boolean;
}

const getCardOwnership = (cardId: string, requiredCount: number, ownedCardsMap: Map<string, number>): CardOwnership => {
    const ownedCount = ownedCardsMap.get(cardId) || 0;
    const missingCount = Math.max(0, requiredCount - ownedCount);
    
    return {
        ownedCount,
        requiredCount,
        missingCount,
        isOwned: ownedCount > 0,
        isMissing: missingCount > 0,
    };
};

const DeckEditor: React.FC<DeckEditorProps> = ({
    deck,
    addCard,
    removeCard,
    onSave,
    onDelete,
    updateDeckInfo,
    saveMessage,
}) => {
    const { cards: allCards } = useCardStore(useShallow(state => ({ cards: state.cards })));
    const allCardsMap = useMemo(() => new Map(allCards.map(c => [c.cardId, c])), [allCards]);
    
    const ownedCards = useCardPoolStore(useShallow(state => state.ownedCards)); 
    
    const [searchTerm, setSearchTerm] = useState('');

    // ãƒ‡ãƒƒã‚­æƒ…å ±ç”¨ã®State (Storeã§ç®¡ç†ã•ã‚Œã‚‹ãŒã€ãƒ­ãƒ¼ã‚«ãƒ«ã§ä¸€æ™‚çš„ã«ä¿æŒ)
    const [deckName, setDeckName] = useState(deck.name);
    const [deckDescription, setDeckDescription] = useState(deck.description);
    
    // Deck Name, Descriptionã®å¤‰æ›´ã‚’å³åº§ã«Storeã«åæ˜ 
    React.useEffect(() => {
        setDeckName(deck.name);
        setDeckDescription(deck.description);
    }, [deck.name, deck.description]);

    const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setDeckName(e.target.value);
        updateDeckInfo({ name: e.target.value });
    };

    const handleDescriptionChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        setDeckDescription(e.target.value);
        updateDeckInfo({ description: e.target.value });
    };

    // æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«
    const filteredCardPool = useMemo(() => {
        const term = searchTerm.toLowerCase();
        if (!term) return allCards;
        
        return allCards.filter(card => 
            card.name.toLowerCase().includes(term) ||
            card.rarity.toLowerCase().includes(term) ||
            card.packId.toLowerCase().includes(term)
        );
    }, [allCards, searchTerm]);


    // ğŸ’¡ ãƒ¡ã‚¤ãƒ³ãƒ‡ãƒƒã‚­/ã‚µã‚¤ãƒ‰ãƒ‡ãƒƒã‚­ã®è¡¨ç¤ºéƒ¨åˆ† (ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°)
    const renderDeckList = (deckMap: Map<string, number>, title: string, deckType: 'mainDeck' | 'sideDeck' | 'extraDeck') => (
        <Box sx={{ mb: 3 }}>
            <Typography variant="h6" gutterBottom>
                {title} ({calculateTotalCards(deckMap)} æš)
            </Typography>
            <List dense sx={{ border: '1px solid #ccc', borderRadius: 1, maxHeight: 350, overflowY: 'auto' }}>
                {Array.from(deckMap.entries()).map(([cardId, count]) => {
                    const cardData = allCardsMap.get(cardId);
                    if (!cardData) return null;

                    const { missingCount, ownedCount, isMissing } = getCardOwnership(cardId, count, ownedCards);

                    return (
                        <ListItem 
                            key={cardId} 
                            secondaryAction={
                                <Box>
                                    <IconButton size="small" onClick={() => addCard(cardId, deckType)}>
                                        <AddIcon fontSize="inherit" />
                                    </IconButton>
                                    <IconButton size="small" onClick={() => removeCard(cardId, deckType)} disabled={count <= 0}>
                                        <RemoveIcon fontSize="inherit" />
                                    </IconButton>
                                </Box>
                            }
                            sx={{ 
                                bgcolor: isMissing ? '#fff0f0' : 'background.paper', // ğŸ’¡ æœªæ‰€æœ‰ã‚«ãƒ¼ãƒ‰ã¯èƒŒæ™¯è‰²å¤‰æ›´
                                borderBottom: '1px solid #eee',
                            }}
                        >
                            <Avatar 
                                src={cardData.imageUrl} 
                                variant="rounded" 
                                sx={{ 
                                    width: 30, height: 42, mr: 1, 
                                    filter: isMissing ? 'grayscale(100%)' : 'none' // ğŸ’¡ æœªæ‰€æœ‰ã‚«ãƒ¼ãƒ‰ã¯ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ
                                }} 
                            />
                            <ListItemText
                                primary={
                                    <Box component="span" sx={{ display: 'flex', alignItems: 'center' }}>
                                        <Typography component="span" sx={{ mr: 1, fontWeight: 'bold' }}>x {count}</Typography>
                                        <Typography component="span" color={isMissing ? 'error' : 'text.primary'}>
                                            {cardData.name}
                                        </Typography>
                                    </Box>
                                }
                                secondary={
                                    isMissing ? (
                                        <Typography variant="caption" color="error" sx={{ fontWeight: 'bold' }}>
                                            ğŸš¨ ä¸è¶³ {missingCount} æš (æ‰€æŒ: {ownedCount})
                                        </Typography>
                                    ) : (
                                        cardData.rarity
                                    )
                                }
                            />
                        </ListItem>
                    );
                })}
                {deckMap.size === 0 && (
                    <ListItem>
                        <ListItemText secondary="ã“ã®ãƒ‡ãƒƒã‚­ã‚¾ãƒ¼ãƒ³ã«ã¯ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚" />
                    </ListItem>
                )}
            </List>
        </Box>
    );


    return (
        <Box sx={{ p: 2 }}>
            <Typography variant="h4" gutterBottom>
                ãƒ‡ãƒƒã‚­ç·¨é›†: {deck.name}
            </Typography>
            <Divider sx={{ mb: 2 }} />
            
            {/* ğŸ’¡ è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° */}
            {deck.hasUnownedCards && (
                <Alert severity="error" sx={{ mb: 2 }}>
                    âš ï¸ **è­¦å‘Š:** ã“ã®ãƒ‡ãƒƒã‚­ã«ã¯ã€ã‚ãªãŸãŒ**æ‰€æœ‰æ•°ã‚ˆã‚Šå¤šã**æŒ‡å®šã—ã¦ã„ã‚‹ã€ã¾ãŸã¯**æ‰€æœ‰ã—ã¦ã„ãªã„ã‚«ãƒ¼ãƒ‰**ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
                </Alert>
            )}
            
            {/* ğŸ’¡ ä¿å­˜ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
            {saveMessage && (
                <Alert severity="success" sx={{ mb: 2 }}>
                    {saveMessage}
                </Alert>
            )}

            <Grid container spacing={3}>
                {/* 1. ãƒ‡ãƒƒã‚­æƒ…å ±ã¨ã‚«ãƒ¼ãƒ‰æ¤œç´¢ (å·¦å´) */}
                <Grid size={{ xs: 12, md: 4 }}>
                    <Paper elevation={3} sx={{ p: 2, mb: 3 }}>
                        <Typography variant="h6" gutterBottom>ãƒ‡ãƒƒã‚­æƒ…å ±</Typography>
                        <TextField
                            label="ãƒ‡ãƒƒã‚­å"
                            fullWidth
                            value={deckName}
                            onChange={handleNameChange}
                            margin="normal"
                        />
                        <TextField
                            label="èª¬æ˜"
                            fullWidth
                            multiline
                            rows={3}
                            value={deckDescription}
                            onChange={handleDescriptionChange}
                            margin="normal"
                        />
                        <Box sx={{ mt: 2, display: 'flex', justifyContent: 'space-between' }}>
                            <Button variant="contained" onClick={onSave} startIcon={<SaveIcon />}>
                                ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜
                            </Button>
                            <Button variant="outlined" color="error" onClick={onDelete} startIcon={<DeleteIcon />}>
                                ãƒ‡ãƒƒã‚­å‰Šé™¤
                            </Button>
                        </Box>
                    </Paper>

                    {/* ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«æ¤œç´¢ã¨è¿½åŠ  */}
                    <Paper elevation={3} sx={{ p: 2 }}>
                        <Typography variant="h6" gutterBottom>ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã‹ã‚‰è¿½åŠ </Typography>
                        <TextField
                            label="ã‚«ãƒ¼ãƒ‰å / ãƒ¬ã‚¢ãƒªãƒ†ã‚£ã§æ¤œç´¢"
                            fullWidth
                            size="small"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            InputProps={{ startAdornment: <InputAdornment position="start"><SearchIcon /></InputAdornment> }}
                            sx={{ mb: 2 }}
                        />
                         
                         {/* æ¤œç´¢çµæœãƒªã‚¹ãƒˆ */}
                         <List dense sx={{ maxHeight: 300, overflow: 'auto', border: '1px solid #ccc', borderRadius: 1 }}>
                            {filteredCardPool.map(card => {
                                const { isOwned } = getCardOwnership(card.cardId, 1, ownedCards);
                                
                                return (
                                    <ListItem 
                                        key={card.cardId}
                                        secondaryAction={
                                            <Button size="small" variant="contained" onClick={() => addCard(card.cardId, 'mainDeck')}>
                                                è¿½åŠ 
                                            </Button>
                                        }
                                    >
                                        <Avatar 
                                            src={card.imageUrl} 
                                            variant="rounded" 
                                            sx={{ 
                                                width: 30, height: 42, mr: 1, 
                                                filter: isOwned ? 'none' : 'grayscale(100%)' // ğŸ’¡ æœªæ‰€æŒã¯ã‚°ãƒ¬ãƒ¼
                                            }} 
                                        />
                                        <ListItemText
                                            primary={card.name}
                                            secondary={card.rarity + (isOwned ? '' : ' (æœªæ‰€æŒ)')}
                                        />
                                    </ListItem>
                                );
                            })}
                         </List>
                         {filteredCardPool.length === 0 && <Alert severity="warning" sx={{ mt: 1 }}>ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚</Alert>}
                    </Paper>
                </Grid>

                {/* 2. ãƒ‡ãƒƒã‚­ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ (å³å´) */}
                <Grid size={{ xs: 12, md: 8 }}>
                    <Paper elevation={3} sx={{ p: 2 }}>
                        {renderDeckList(deck.mainDeck, 'ãƒ¡ã‚¤ãƒ³ãƒ‡ãƒƒã‚­', 'mainDeck')}
                        <Divider sx={{ my: 2 }} />
                        {renderDeckList(deck.sideDeck, 'ã‚µã‚¤ãƒ‰ãƒ‡ãƒƒã‚­', 'sideDeck')}
                        <Divider sx={{ my: 2 }} />
                        {renderDeckList(deck.extraDeck, 'ã‚¨ã‚¯ã‚¹ãƒˆãƒ©ãƒ‡ãƒƒã‚­', 'extraDeck')}
                    </Paper>
                </Grid>
            </Grid>
        </Box>
    );
};

export default DeckEditor;