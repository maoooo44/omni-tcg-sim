// src/service/deck-logic/deckService.ts

import { db } from "../database/db";
import type { Deck } from '../../models/deck';
import { v4 as uuidv4 } from 'uuid'; 

/**
 * IndexedDB (Dexie) の 'decks' テーブルに対する CRUD 操作を扱うサービス
 */
export const deckService = {

    /**
     * Map<string, number> を JSON互換の Record<string, number> に変換するユーティリティ
     */
    mapToRecord(deckMap: Map<string, number>): Record<string, number> {
        return Object.fromEntries(deckMap);
    },

    /**
     * JSON互換の Record<string, number> を Map<string, number> に変換するユーティリティ
     */
    recordToMap(deckRecord: Record<string, number>): Map<string, number> {
        return new Map(Object.entries(deckRecord));
    },

    /**
     * デッキデータをDB保存用に整形する (Deck -> DB Record)
     */
    prepareForDB(deck: Deck): any {
        // MapをRecordに変換してDBに保存できる形式にする
        return {
            ...deck,
            mainDeck: this.mapToRecord(deck.mainDeck),
            sideDeck: this.mapToRecord(deck.sideDeck),
            extraDeck: this.mapToRecord(deck.extraDeck),
        };
    },
    
    /**
     * DBから取得したデッキデータをアプリケーション用に整形する (DB Record -> Deck)
     */
    prepareFromDB(dbDeck: any): Deck {
        // DBから取得したRecordをMapに戻す
        return {
            ...dbDeck,
            mainDeck: this.recordToMap(dbDeck.mainDeck),
            sideDeck: this.recordToMap(dbDeck.sideDeck),
            extraDeck: this.recordToMap(dbDeck.extraDeck),
        };
    },

    /**
     * 新しいデッキをIndexedDBに保存する。（IDはDeckオブジェクトに含まれる）
     * @param deckData - 作成する Deck データ
     * @returns 保存されたデッキのID
     */
    async createDeck(deckData: Deck): Promise<string> {
        try {
            const dbData = this.prepareForDB(deckData);
            // Dexieのadd()は主キー(deckId)を返す
            const id = await db.decks.add(dbData); 
            console.log(`Deck created with ID: ${id}`);
            return id as string;
        } catch (error) {
            console.error("Failed to create deck:", error);
            throw new Error("デッキの作成に失敗しました。");
        }
    },
    
    /**
     * IDを指定して特定のデッキを取得する。
     */
    async getDeckById(deckId: string): Promise<Deck | null> {
        try {
            const dbDeck = await db.decks.get(deckId);
            if (!dbDeck) return null;
            return this.prepareFromDB(dbDeck); 
        } catch (error) {
            console.error("Failed to get deck by ID:", error);
            return null;
        }
    },

    /**
     * 全てのデッキデータをIndexedDBから取得する。
     */
    async getAllDecks(): Promise<Deck[]> {
        try {
            const dbDecks = await db.decks.toArray();
            return dbDecks.map(this.prepareFromDB);
        } catch (error) {
            console.error("Failed to load all decks:", error);
            return [];
        }
    },
    
    /**
     * 既存のデッキを更新または新規作成する。
     */
    async saveDeck(deck: Deck): Promise<void> {
        try {
            const dbData = this.prepareForDB(deck);
            await db.decks.put(dbData);
            console.log(`Deck ${deck.deckId} saved successfully.`);
        } catch (error) {
            console.error(`Failed to save deck ${deck.deckId}:`, error);
            throw new Error("デッキの保存に失敗しました。");
        }
    },
    
    /**
     * IDを指定してデッキを削除する。
     */
    async deleteDeck(deckId: string): Promise<void> {
        try {
            await db.decks.delete(deckId);
            console.log(`Deck ${deckId} deleted successfully.`);
        } catch (error) {
            console.error(`Failed to delete deck ${deckId}:`, error);
            throw new Error("デッキの削除に失敗しました。");
        }
    },

    /**
     * デッキの配列を一括でインポートする。IDが重複する場合はリネームする。
     */
    async importDecks(decksToImport: Deck[]): Promise<{ importedCount: number, renamedCount: number }> {
        const existingDecks = await db.decks.toArray();
        const existingIds = new Set(existingDecks.map(d => d.deckId));
        
        const decksToBulkAdd: any[] = [];
        let renamedCount = 0;

        // 1. ID衝突のチェックと回避
        decksToImport.forEach(deck => {
            let newDeck = { ...deck };
            
            // 既存IDとの衝突チェック
            if (existingIds.has(deck.deckId)) {
                // 衝突した場合、新しいユニークなIDを割り当てる
                const newId = uuidv4(); 
                newDeck = { 
                    ...deck, 
                    deckId: newId,
                    name: `${deck.name} (Imported: ${newId.substring(0, 4)})`
                };
                renamedCount++;
            }
            
            // 2. Map構造をDB保存用のRecord形式に変換
            newDeck.updatedAt = new Date().toISOString(); 
            
            decksToBulkAdd.push(this.prepareForDB(newDeck));
        });

        if (decksToBulkAdd.length === 0) {
            return { importedCount: 0, renamedCount: 0 };
        }

        try {
            // 3. デッキを一括追加 (bulkAdd)
            await db.decks.bulkAdd(decksToBulkAdd);
            console.log(`${decksToBulkAdd.length} decks imported/renamed successfully.`);
            
            return { 
                importedCount: decksToBulkAdd.length, 
                renamedCount: renamedCount 
            };
        } catch (error) {
            console.error("Failed to bulk import decks:", error);
            throw new Error("デッキの一括インポートに失敗しました。");
        }
    },
};