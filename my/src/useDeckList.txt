// src/features/deck-management/hooks/useDeckList.ts

import { useState, useEffect } from 'react';
import type { Deck } from '../../../models/deck';
import { deckService } from '../../../services/deck-logic/deckService'; // ğŸ’¡ ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

/**
 * ãƒ‡ãƒƒã‚­ä¸€è¦§ã®ãƒ­ãƒ¼ãƒ‰ã€çŠ¶æ…‹ç®¡ç†ã€å‰Šé™¤ãªã©ã®æ“ä½œã‚’æ‹…ã†ã‚«ã‚¹ã‚¿ãƒ  Hook
 */
export const useDeckList = () => {
    // ğŸ’¡ Deck[] ã¯ Map<string, number> ã‚’å«ã‚€ãŸã‚ã€useStateã®å‹ã¨ã—ã¦å®šç¾©
    const [decks, setDecks] = useState<Deck[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    const loadDecks = async () => {
        setIsLoading(true);
        try {
            // ğŸ’¡ deckServiceã‹ã‚‰å…¨ãƒ‡ãƒƒã‚­ã‚’ãƒ­ãƒ¼ãƒ‰
            const allDecks = await deckService.getAllDecks();
            setDecks(allDecks);
        } catch (error) {
            console.error('Failed to load decks:', error);
            setDecks([]);
        } finally {
            setIsLoading(false);
        }
    };

    // åˆæœŸãƒ­ãƒ¼ãƒ‰
    useEffect(() => {
        loadDecks();
    }, []);

    /**
     * ãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã—ã€ãƒªã‚¹ãƒˆã‚’å†èª­ã¿è¾¼ã¿ã™ã‚‹
     * @param deckId - å‰Šé™¤å¯¾è±¡ã®ãƒ‡ãƒƒã‚­ID
     */
    const handleDeleteDeck = async (deckId: string) => {
        if (!window.confirm("ã“ã®ãƒ‡ãƒƒã‚­ã‚’æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) {
            return;
        }
        try {
            await deckService.deleteDeck(deckId);
            // å‰Šé™¤ãŒæˆåŠŸã—ãŸã‚‰ãƒªã‚¹ãƒˆã‚’æ›´æ–° (ãƒ­ãƒ¼ã‚«ãƒ«ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°)
            setDecks(prev => prev.filter(deck => deck.deckId !== deckId));
            console.log(`Deck ${deckId} deleted.`);
        } catch (error) {
            alert("ãƒ‡ãƒƒã‚­ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
            console.error(error);
        }
    };

    // ç·ã‚«ãƒ¼ãƒ‰æšæ•°ã‚’è¨ˆç®—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    const calculateTotalCards = (deck: Deck): number => {
        // ğŸ’¡ Mapã®valuesã‚’åˆè¨ˆ
        const main = Array.from(deck.mainDeck.values()).reduce((sum, count) => sum + count, 0);
        const side = Array.from(deck.sideDeck.values()).reduce((sum, count) => sum + count, 0);
        const extra = Array.from(deck.extraDeck.values()).reduce((sum, count) => sum + count, 0);
        return main + side + extra;
    };


    return {
        decks,
        isLoading,
        handleDeleteDeck,
        calculateTotalCards,
        loadDecks,
    };
};