// src/features/card-pool/hooks/useCardPoolDisplay.ts

import { useState, useMemo, useCallback, useEffect } from 'react';
import { useShallow } from 'zustand/react/shallow';
import { useCardPoolStore, type CardPoolState } from '../../../stores/cardPoolStore'; 
import { useUserDataStore } from '../../../stores/userDataStore'; 
import { useCardStore } from '../../../stores/cardStore'; 

import type { Card as CardType } from '../../../models/card'; 

export const CARDS_PER_PAGE = 30; 
export type SortKey = 'name' | 'pack' | 'count';


// --- ÂûãÂÆöÁæ© ---

export interface OwnedCardDisplay extends CardType {
    count: number;
    description: string; 
}

export interface CardPoolFilters {
    search: string | null;
    packId: string | null;
    rarity: string | null;
}

interface CardPoolDisplayState {
    loading: boolean;
    error: Error | null;
    filteredCards: OwnedCardDisplay[];
    filter: CardPoolFilters;
    setFilter: (newFilter: Partial<CardPoolFilters>) => void;
    currentPage: number;
    totalPages: number;
    setCurrentPage: (page: number) => void;
    sortKey: SortKey; 
    setSortKey: (key: SortKey) => void;
    sortOrder: 'asc' | 'desc';
    setSortOrder: (order: 'asc' | 'desc') => void;
    // üí° ‰øÆÊ≠£: resetPool „ÅÆÈùûÂêåÊúüÂåñ„Å´‰º¥„ÅÑ„ÄÅresetCollection „ÇÇÈùûÂêåÊúüÂá¶ÁêÜ„ÇíÊÉ≥ÂÆö
    resetCollection: () => Promise<void>; 
}

// --- „Ç´„Çπ„Çø„É†„Éï„ÉÉ„ÇØ ---

export const useCardPoolDisplay = (): CardPoolDisplayState => {
    
    // resetPool „ÅØ cardPoolStore.ts „Åß async „Å´Â§âÊõ¥„Åï„Çå„Å¶„ÅÑ„Çã
    const { ownedCards, loadCardPool, resetPool } = useCardPoolStore(
        useShallow((state: CardPoolState) => ({ 
            ownedCards: state.ownedCards, 
            loadCardPool: state.loadCardPool,
            // resetPool „Åå async „Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÂâçÊèê„Å®„Åô„Çã
            resetPool: state.resetPool,
        }))
    );

    const isDTCGEnabled = useUserDataStore(useShallow(state => state.isDTCGEnabled));
    const allCards = useCardStore(useShallow(state => state.cards || []));

    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);
    const [filter, setInternalFilter] = useState<CardPoolFilters>({
        search: null,
        packId: null,
        rarity: null,
    });
    const [currentPage, setCurrentPage] = useState(1);
    const [sortKey, setSortKey] = useState<SortKey>('name');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');
    
    // ÂàùÊúü„É≠„Éº„Éâ
    useEffect(() => {
        const initialize = async () => {
            try {
                setLoading(true);
                await loadCardPool();
            } catch (err) {
                setError(err as Error);
            } finally {
                setLoading(false);
            }
        };
        initialize();
    }, [loadCardPool]);

    // „Éï„Ç£„É´„Çø„ÉºÁä∂ÊÖã„ÇíÊõ¥Êñ∞„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
    const setFilter = useCallback((newFilter: Partial<CardPoolFilters>) => {
        setInternalFilter(prev => ({ ...prev, ...newFilter }));
    }, []);

    // OwnedCardDisplay „ÅÆ„É™„Çπ„Éà„Çí‰ΩúÊàê
    const ownedCardDisplayList = useMemo((): OwnedCardDisplay[] => {
        const cardMap = new Map<string, CardType>(allCards.map(card => [card.cardId, card]));
        const ownedList: OwnedCardDisplay[] = [];
        
        ownedCards.forEach((count, cardId: string) => { 
            const card = cardMap.get(cardId);
            if (card) {
                ownedList.push({
                    ...card,
                    count: count,
                    // cardType„Å´description„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„Åü„ÇÅ„ÄÅany„Å´„Ç≠„É£„Çπ„Éà„Åó„Å¶„Ç¢„ÇØ„Çª„Çπ
                    description: (card as any).description || '', 
                });
            }
        });
        
        return ownedList.filter(card => isDTCGEnabled ? card.count > 0 : true);

    }, [ownedCards, allCards, isDTCGEnabled]);

    // „Éï„Ç£„É´„Çø„Éº„Å®„ÇΩ„Éº„Éà„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ
    const filteredAndSortedCards = useMemo(() => {
        let list = ownedCardDisplayList;

        // 1. „Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        list = list.filter(card => {
            let pass = true;
            
            // Ê§úÁ¥¢„Éï„Ç£„É´„Çø„Éº
            if (filter.search) {
                const searchLower = filter.search.toLowerCase();
                pass = pass && (
                    card.name.toLowerCase().includes(searchLower) ||
                    card.description.toLowerCase().includes(searchLower) 
                );
            }

            // „Éë„ÉÉ„ÇØ„Éï„Ç£„É´„Çø„Éº
            if (filter.packId) {
                pass = pass && card.packId === filter.packId;
            }

            // „É¨„Ç¢„É™„ÉÜ„Ç£„Éï„Ç£„É´„Çø„Éº
            if (filter.rarity) {
                pass = pass && card.rarity === filter.rarity;
            }
            
            return pass;
        });

        // 2. „ÇΩ„Éº„Éà
        list.sort((a, b) => {
            let comparison = 0;
            
            switch (sortKey) {
                case 'name':
                    comparison = a.name.localeCompare(b.name);
                    break;
                case 'pack':
                    comparison = a.packId.localeCompare(b.packId);
                    break;
                case 'count':
                    comparison = (a.count || 0) - (b.count || 0);
                    break;
            }

            return sortOrder === 'asc' ? comparison : -comparison;
        });
        
        return list;
    }, [ownedCardDisplayList, filter, sortKey, sortOrder]);
    
    // „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„ÅÆË®àÁÆó
    const totalPages = useMemo(() => {
        return Math.max(1, Math.ceil(filteredAndSortedCards.length / CARDS_PER_PAGE));
    }, [filteredAndSortedCards.length]);

    // „Éö„Éº„Ç∏Áï™Âè∑„ÅÆ„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    useEffect(() => {
        if (currentPage > totalPages) {
            setCurrentPage(totalPages);
        }
    }, [currentPage, totalPages]);
    
    // „Çπ„Éà„Ç¢„ÅÆ„É™„Çª„ÉÉ„Éà„Ç¢„ÇØ„Ç∑„Éß„É≥
    // üõ†Ô∏è ‰øÆÊ≠£: resetPool „Åå async „Å™„ÅÆ„Åß„ÄÅ„Åì„Å°„Çâ„ÇÇ async/await „Å´ÂØæÂøú (TS2322 ‰øÆÊ≠£)
    const resetCollection = useCallback(async () => {
        await resetPool();
        setInternalFilter({ search: null, packId: null, rarity: null });
        setCurrentPage(1);
    }, [resetPool]);


    return {
        loading,
        error,
        filteredCards: filteredAndSortedCards,
        filter,
        setFilter,
        currentPage,
        totalPages,
        setCurrentPage,
        sortKey,
        setSortKey,
        sortOrder,
        setSortOrder,
        resetCollection,
    };
};