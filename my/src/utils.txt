// src/utils/randomUtils.ts
/**
 * ãƒ©ãƒ³ãƒ€ãƒ æŠ½é¸ã«é–¢ã™ã‚‹æ±ç”¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
 */

// æ±ç”¨çš„ãªè¨­å®šå‹ã‚’å®šç¾©ï¼ˆã©ã®ãƒ¬ã‚¢ãƒªãƒ†ã‚£è¨­å®šã§ã‚‚ä½¿ç”¨ã§ãã‚‹ã‚ˆã† Pack ã‹ã‚‰åˆ‡ã‚Šé›¢ã™ï¼‰
export interface WeightedItem {
  key: string;      // çµæœã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ï¼ˆä¾‹: ãƒ¬ã‚¢ãƒªãƒ†ã‚£åï¼‰
  probability: number; // æŠ½é¸ç¢ºç‡ (0.0 ã‹ã‚‰ 1.0 ã®é–“)
}

/**
 * ç´¯ç©ç¢ºç‡æ³•ã«åŸºã¥ãã€é‡ã¿ä»˜ã‘ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆã‹ã‚‰ä¸€ã¤ã‚’é¸æŠã™ã‚‹ã€‚
 * æ±ç”¨çš„ãªãƒ­ã‚¸ãƒƒã‚¯ã§ã‚ã‚Šã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§å†åˆ©ç”¨å¯èƒ½ã€‚
 * @param weightedItems - ç¢ºç‡è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—ï¼ˆç¢ºç‡ã®åˆè¨ˆã¯1.0ã§ã‚ã‚‹ã“ã¨ï¼‰
 * @returns æŠ½é¸ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã®ã‚­ãƒ¼ (string)
 */
export const selectWeightedItem = (weightedItems: WeightedItem[]): string => {
    // 0.0 ä»¥ä¸Š 1.0 æœªæº€ã®ä¹±æ•°ã‚’ç”Ÿæˆ
    const randomNumber = Math.random();
    let cumulativeProbability = 0;

    for (const item of weightedItems) {
        // ç¢ºç‡ã‚’åŠ ç®— (ç´¯ç©)
        cumulativeProbability += item.probability;

        // ä¹±æ•°ãŒç´¯ç©ç¢ºç‡ã®é–¾å€¤ä»¥ä¸‹ã§ã‚ã‚Œã°ã€ãã®ã‚¢ã‚¤ãƒ†ãƒ ãŒå½“é¸
        if (randomNumber < cumulativeProbability) {
            return item.key;
        }
    }

    // æµ®å‹•å°æ•°ç‚¹èª¤å·®å¯¾ç­–ã¨ã—ã¦ã€æœ€å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿”ã™
    return weightedItems[weightedItems.length - 1].key;
};



// src/utils/uuidUtils.ts
import { v4 as uuidv4 } from 'uuid'; 

/**
 * æ¥­ç•Œæ¨™æº–ã®UUID v4 (Universally Unique Identifier) ã‚’ç”Ÿæˆã™ã‚‹æ±ç”¨é–¢æ•°ã€‚
 * ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®ã™ã¹ã¦ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£IDç”Ÿæˆã«ä½¿ç”¨ã§ãã¾ã™ã€‚
 * @returns {string} ç”Ÿæˆã•ã‚ŒãŸãƒ¦ãƒ‹ãƒ¼ã‚¯ãªUUID
 */
export const generateUUID = (): string => {
    return uuidv4();
};




// src/utils/validationUtils.ts
// æµ®å‹•å°æ•°ç‚¹æ•°è¨ˆç®—ã®è¨±å®¹èª¤å·®
const EPSILON = 0.0001;

/**
 * ç¢ºç‡è¨­å®šã®åˆè¨ˆå€¤ãŒæœŸå¾…å€¤ã¨ä¸€è‡´ã™ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹æ±ç”¨é–¢æ•°ã€‚
 * * ğŸ’¡ ä¿®æ­£: expectedTotal ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­ã‘ãšã€å¿…é ˆå¼•æ•°ã¨ã—ã¾ã™ã€‚
 * ã¾ãŸã€å‹ã‚’ { probability: number }[] ã«ã™ã‚‹ã“ã¨ã§ RarityConfig ä»¥å¤–ã«ã‚‚æµç”¨å¯èƒ½ã«ã€‚
 * * @param config - å„è¦ç´ ã« probability: number ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
 * @param expectedTotal - æœŸå¾…ã•ã‚Œã‚‹åˆè¨ˆå€¤ (ä¾‹: 1.0, Pack.cardsPerPackãªã©)
 * @returns åˆè¨ˆãŒæœŸå¾…å€¤ã¨ä¸€è‡´ã—ãªã„å ´åˆã« true
 */
export const hasProbabilityMismatch = (
    config: Array<{ probability: number }>,
    expectedTotal: number
): boolean => {
    // ç¢ºç‡ã‚’åˆè¨ˆã—ã€å°æ•°ç‚¹ä»¥ä¸‹ã®ç²¾åº¦ã‚’è€ƒæ…®ã—ã¦ãƒã‚§ãƒƒã‚¯
    const totalProbability = config.reduce((sum, item) => sum + item.probability, 0);
    
    // è¨±å®¹èª¤å·®ç¯„å›²å†…ã§æ¯”è¼ƒ
    return Math.abs(totalProbability - expectedTotal) > EPSILON;
};

// ----------------------------------------------------
// ãƒ‡ãƒƒã‚­æšæ•°ãƒã‚§ãƒƒã‚¯ç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° (ãƒ‡ãƒƒã‚­æšæ•°ãƒã‚§ãƒƒã‚¯ã«æµç”¨å¯èƒ½)
// ----------------------------------------------------

/**
 * Mapã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã®ç·æšæ•°ã‚’è¨ˆç®—ã™ã‚‹ã€‚
 * @param deckMap - Map<string, number> (cardId: count)
 * @returns ç·æšæ•°
 */
export const calculateMapTotalCount = (deckMap: Map<string, number>): number => {
    // Mapã®valuesã‚’åˆè¨ˆ
    return Array.from(deckMap.values()).reduce((sum, count) => sum + count, 0);
};

/**
 * ãƒ‡ãƒƒã‚­ã®æšæ•°ãŒæŒ‡å®šã•ã‚ŒãŸç¯„å›²å†…ã«ã‚ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹æ±ç”¨é–¢æ•°ã€‚
 * * ğŸ’¡ ä¿®æ­£: é–¢æ•°åã‚’ã‚ˆã‚Šæ±ç”¨çš„ãª validateDeckCount ã«å¤‰æ›´
 * * @param deckMap - ãƒ¡ã‚¤ãƒ³ãƒ‡ãƒƒã‚­ã‚„ã‚µã‚¤ãƒ‰ãƒ‡ãƒƒã‚­ã® Map<cardId, count>
 * @param min - æœ€å°æšæ•°
 * @param max - æœ€å¤§æšæ•°
 * @returns ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ | null
 */
export const validateDeckCount = (
    deckMap: Map<string, number>,
    min: number,
    max: number
): string | null => {
    const totalCards = calculateMapTotalCount(deckMap);
    
    if (totalCards < min) {
        return `æšæ•°ãŒä¸è¶³ã—ã¦ã„ã¾ã™ (${totalCards} / æœ€å° ${min} æš)ã€‚`;
    }
    
    if (totalCards > max) {
        return `æšæ•°ãŒè¶…éã—ã¦ã„ã¾ã™ (${totalCards} / æœ€å¤§ ${max} æš)ã€‚`;
    }
    
    return null;
};