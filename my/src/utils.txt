// src/utils/randomUtils.ts
/**
 * ランダム抽選に関する汎用ユーティリティ関数
 */

// 汎用的な設定型を定義（どのレアリティ設定でも使用できるよう Pack から切り離す）
export interface WeightedItem {
  key: string;      // 結果を識別するためのキー（例: レアリティ名）
  probability: number; // 抽選確率 (0.0 から 1.0 の間)
}

/**
 * 累積確率法に基づき、重み付けされたアイテムのリストから一つを選択する。
 * 汎用的なロジックであり、アプリケーション全体で再利用可能。
 * @param weightedItems - 確率設定オブジェクトの配列（確率の合計は1.0であること）
 * @returns 抽選によって決定されたアイテムのキー (string)
 */
export const selectWeightedItem = (weightedItems: WeightedItem[]): string => {
    // 0.0 以上 1.0 未満の乱数を生成
    const randomNumber = Math.random();
    let cumulativeProbability = 0;

    for (const item of weightedItems) {
        // 確率を加算 (累積)
        cumulativeProbability += item.probability;

        // 乱数が累積確率の閾値以下であれば、そのアイテムが当選
        if (randomNumber < cumulativeProbability) {
            return item.key;
        }
    }

    // 浮動小数点誤差対策として、最後のアイテムを返す
    return weightedItems[weightedItems.length - 1].key;
};



// src/utils/uuidUtils.ts
import { v4 as uuidv4 } from 'uuid'; 

/**
 * 業界標準のUUID v4 (Universally Unique Identifier) を生成する汎用関数。
 * アプリケーション内のすべてのエンティティID生成に使用できます。
 * @returns {string} 生成されたユニークなUUID
 */
export const generateUUID = (): string => {
    return uuidv4();
};




// src/utils/validationUtils.ts
// 浮動小数点数計算の許容誤差
const EPSILON = 0.0001;

/**
 * 確率設定の合計値が期待値と一致するかをチェックする汎用関数。
 * * 💡 修正: expectedTotal にデフォルト値を設けず、必須引数とします。
 * また、型を { probability: number }[] にすることで RarityConfig 以外にも流用可能に。
 * * @param config - 各要素に probability: number を持つオブジェクトの配列
 * @param expectedTotal - 期待される合計値 (例: 1.0, Pack.cardsPerPackなど)
 * @returns 合計が期待値と一致しない場合に true
 */
export const hasProbabilityMismatch = (
    config: Array<{ probability: number }>,
    expectedTotal: number
): boolean => {
    // 確率を合計し、小数点以下の精度を考慮してチェック
    const totalProbability = config.reduce((sum, item) => sum + item.probability, 0);
    
    // 許容誤差範囲内で比較
    return Math.abs(totalProbability - expectedTotal) > EPSILON;
};

// ----------------------------------------------------
// デッキ枚数チェック用のヘルパー関数 (デッキ枚数チェックに流用可能)
// ----------------------------------------------------

/**
 * Mapで管理されているカードの総枚数を計算する。
 * @param deckMap - Map<string, number> (cardId: count)
 * @returns 総枚数
 */
export const calculateMapTotalCount = (deckMap: Map<string, number>): number => {
    // Mapのvaluesを合計
    return Array.from(deckMap.values()).reduce((sum, count) => sum + count, 0);
};

/**
 * デッキの枚数が指定された範囲内にあるかをチェックする汎用関数。
 * * 💡 修正: 関数名をより汎用的な validateDeckCount に変更
 * * @param deckMap - メインデッキやサイドデッキの Map<cardId, count>
 * @param min - 最小枚数
 * @param max - 最大枚数
 * @returns バリデーションエラーメッセージ | null
 */
export const validateDeckCount = (
    deckMap: Map<string, number>,
    min: number,
    max: number
): string | null => {
    const totalCards = calculateMapTotalCount(deckMap);
    
    if (totalCards < min) {
        return `枚数が不足しています (${totalCards} / 最小 ${min} 枚)。`;
    }
    
    if (totalCards > max) {
        return `枚数が超過しています (${totalCards} / 最大 ${max} 枚)。`;
    }
    
    return null;
};