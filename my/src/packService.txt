// src/services/pack-logic/packService.ts
import { db } from "../database/db";
import type { Pack } from "../../models/pack";
import { createDefaultPack } from "./packUtils";

/**
 * IndexedDB (Dexie) ã® 'packs' ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã™ã‚‹ CRUD æ“ä½œã‚’æ‰±ã†ã‚µãƒ¼ãƒ“ã‚¹
 */
export const packService = {

    /**
     * ãƒ‘ãƒƒã‚¯ã‚’æ–°è¦ä½œæˆã—ã€IndexedDBã«ä¿å­˜ã™ã‚‹ã€‚
     * @param packData - ä¿å­˜ã™ã‚‹ Pack ãƒ‡ãƒ¼ã‚¿
     * @returns ä¿å­˜ã•ã‚ŒãŸãƒ‘ãƒƒã‚¯ã®ID
     */
    async createPack(packData: Pack = createDefaultPack()): Promise<string> {
        try {
            // isOpened: false ã‚’å¼·åˆ¶ (æ–°è¦ä½œæˆã®ãŸã‚)
            const id = await db.packs.add({ ...packData, isOpened: false }); 
            console.log(`Pack created with ID: ${id}`);
            return id as string;
        } catch (error) {
            console.error("Failed to create pack:", error);
            throw new Error("ãƒ‘ãƒƒã‚¯ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        }
    },

    /**
     * IDã‚’æŒ‡å®šã—ã¦ç‰¹å®šã®ãƒ‘ãƒƒã‚¯ã‚’å–å¾—ã™ã‚‹ã€‚
     * @param packId - å–å¾—ã—ãŸã„ãƒ‘ãƒƒã‚¯ã®ID
     * @returns Pack ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¾ãŸã¯è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã¯ null
     */
    async getPackById(packId: string): Promise<Pack | null> {
        try {
            const pack = await db.packs.get(packId);
            return pack ?? null;
        } catch (error) {
            console.error(`Failed to get pack ${packId}:`, error);
            return null;
        }
    },
    
    /**
     * IndexedDBã‹ã‚‰ä¿å­˜ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®ãƒ‘ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã€‚ï¼ˆğŸ’¡ æ–°è¦è¿½åŠ ï¼‰
     * @returns Pack[] ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
     */
    async getAllPacks(): Promise<Pack[]> {
        try {
            const packs = await db.packs.toArray();
            return packs;
        } catch (error) {
            console.error("Failed to load all packs from DB:", error);
            // å¤±æ•—æ™‚ã¯ç©ºã®é…åˆ—ã‚’è¿”ã™
            return [];
        }
    },


    /**
     * ãƒ‘ãƒƒã‚¯ã‚’æ›´æ–°ã™ã‚‹ã€‚
     * @param packId - æ›´æ–°å¯¾è±¡ã®ãƒ‘ãƒƒã‚¯ID
     * @param updatedData - æ›´æ–°ãƒ‡ãƒ¼ã‚¿
     */
    async updatePack(packId: string, updatedData: Partial<Pack>): Promise<void> {
        try {
            await db.packs.update(packId, updatedData);
        } catch (error) {
            console.error(`Failed to update pack ${packId}:`, error);
            throw new Error("ãƒ‘ãƒƒã‚¯ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        }
    },

    /**
     * ãƒ‘ãƒƒã‚¯ã‚’å‰Šé™¤ã™ã‚‹ã€‚
     * @param packId - å‰Šé™¤å¯¾è±¡ã®ãƒ‘ãƒƒã‚¯ID
     */
    async deletePack(packId: string): Promise<void> {
        try {
            await db.packs.delete(packId);
        } catch (error) {
            console.error(`Failed to delete pack ${packId}:`, error);
            throw new Error("ãƒ‘ãƒƒã‚¯ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        }
    },

    /**
     * è¤‡æ•°ã®ãƒ‘ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã€‚
     * æ—¢å­˜ã®IDã¨é‡è¤‡ã™ã‚‹ãƒ‘ãƒƒã‚¯ã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã‚‹ã€‚
     * @param packsToImport - ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‘ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã®é…åˆ—
     * @returns ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ‘ãƒƒã‚¯ã®æ•°ã¨ã‚¹ã‚­ãƒƒãƒ—ã•ã‚ŒãŸIDã®ãƒªã‚¹ãƒˆ
     */
    async importPacks(packsToImport: Pack[]): Promise<{ importedCount: number, skippedIds: string[] }> {
        const existingPacks = await db.packs.toArray();
        const existingIds = new Set(existingPacks.map(p => p.packId));
        
        const newPacks: Pack[] = [];
        const skippedIds: string[] = [];

        // 1. é‡è¤‡ãƒã‚§ãƒƒã‚¯ã¨æ–°è¦ãƒ‘ãƒƒã‚¯ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        packsToImport.forEach(pack => {
            // ãƒ‘ãƒƒã‚¯ã®å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒã‚§ãƒƒã‚¯ï¼ˆIDã¨ä¾¡æ ¼ï¼‰
            if (!pack.packId || pack.price === undefined) {
                 console.warn("Skipping invalid pack data: Missing packId or price.");
                 return;
            }

            if (existingIds.has(pack.packId)) {
                skippedIds.push(pack.packId);
            } else {
                newPacks.push({
                    ...pack,
                    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒ isOpened ã‚’æŒãŸãªã„å ´åˆã‚’è€ƒæ…®ã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ false
                    isOpened: pack.isOpened ?? false, 
                });
            }
        });

        if (newPacks.length === 0) {
            return { importedCount: 0, skippedIds };
        }

        try {
            // 2. æ–°è¦ãƒ‘ãƒƒã‚¯ã‚’ä¸€æ‹¬è¿½åŠ  (bulkAdd)
            await db.packs.bulkAdd(newPacks);
            console.log(`${newPacks.length} packs imported successfully.`);
            
            return { 
                importedCount: newPacks.length, 
                skippedIds 
            };
        } catch (error) {
            console.error("Failed to import packs:", error);
            throw new Error("ãƒ‘ãƒƒã‚¯ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        }
    },
};