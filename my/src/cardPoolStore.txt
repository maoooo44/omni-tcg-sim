// src/stores/cardPoolStore.ts
import { create } from 'zustand';
import { cardPoolService } from '../services/card-pool/cardPoolService'; 

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚«ãƒ¼ãƒ‰è³‡ç”£ã®çŠ¶æ…‹
export interface CardPoolState {
    // key: cardId (string), value: æ‰€æœ‰æšæ•° (number)
    ownedCards: Map<string, number>;
    totalOwnedCards: number;

    // --- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
    /** DBã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚¹ãƒˆã‚¢ã‚’åˆæœŸåŒ– */
    loadCardPool: () => Promise<void>; 
    /** ãƒ‘ãƒƒã‚¯é–‹å°ãªã©ã«ã‚ˆã£ã¦ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ  */
    addCards: (cards: { cardId: string, count: number, packId: string }[]) => Promise<void>;
    /** ãƒ‡ãƒƒã‚­æ§‹ç¯‰ãªã©ã«ã‚ˆã£ã¦ã‚«ãƒ¼ãƒ‰ã®æšæ•°ã‚’æ›´æ–° */
    setCardCount: (cardId: string, count: number) => Promise<void>;
    /** ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰ */
    resetPool: () => Promise<void>; // ğŸ’¡ Promise<void> ã«å¤‰æ›´
    /** ğŸ’¡ ZIPã‚¤ãƒ³ãƒãƒ¼ãƒˆ: ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’DBã¨ã‚¹ãƒˆã‚¢ã«ä¸Šæ›¸ãã™ã‚‹ */
    importCardPool: (importedOwnedCards: Map<string, number>) => Promise<void>;
}

const initialState = {
    ownedCards: new Map<string, number>(), // å‹ã‚’æ˜ç¤º
    totalOwnedCards: 0,
};

// ğŸ’¡ get ã‚’ _get ã«å¤‰æ›´ã—ã€æœªä½¿ç”¨ã®è­¦å‘Šã‚’å›é¿
export const useCardPoolStore = create<CardPoolState>((set, _get) => ({
    ...initialState,
    
    // ğŸ’¡ å®Ÿè£…1: DBã‹ã‚‰ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã™ã‚‹
    loadCardPool: async () => {
        try {
            // DBã‹ã‚‰Mapå½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const ownedCards = await cardPoolService.getOwnedCardsMap();
            
            // ç·æšæ•°ã‚’è¨ˆç®—
            let newTotal = 0;
            ownedCards.forEach(count => {
                newTotal += count;
            });

            // ã‚¹ãƒˆã‚¢ã«åæ˜ 
            set({ 
                ownedCards, 
                totalOwnedCards: newTotal 
            });
            console.log(`âœ… [CardPoolStore] Loaded ${ownedCards.size} unique cards, total ${newTotal} cards.`);

        } catch (error) {
            console.error('Failed to load card pool:', error);
            // å¤±æ•—æ™‚ã¯åˆæœŸçŠ¶æ…‹ã‚’ç¶­æŒ
        }
    },

    // ğŸ’¡ å®Ÿè£…2: ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã€DBã«ä¿å­˜ã™ã‚‹
    addCards: async (cards) => {
        const countsToUpdate = new Map<string, number>();

        set(state => {
            const newOwnedCards = new Map(state.ownedCards);
            let newTotal = state.totalOwnedCards;

            cards.forEach(({ cardId, count }) => {
                // æ–°ã—ã„æ‰€æœ‰æšæ•°ã‚’è¨ˆç®—
                const currentCount = newOwnedCards.get(cardId) || 0;
                const newCount = currentCount + count;
                
                // ã‚¹ãƒˆã‚¢ã®Mapã‚’æ›´æ–°
                newOwnedCards.set(cardId, newCount);
                // DBã«æ›´æ–°ã™ã¹ãMapã«ã‚‚è¿½åŠ 
                countsToUpdate.set(cardId, newCount);
                
                newTotal += count;
            });

            return { 
                ownedCards: newOwnedCards, 
                totalOwnedCards: newTotal 
            };
        });

        // ğŸ› ï¸ DBã¸å¤‰æ›´ã‚’ä¿å­˜ (éåŒæœŸ)
        try {
            // cardPoolService.bulkUpdateCardCounts ã¯ Map ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾ DB ã«åæ˜ 
            await cardPoolService.bulkUpdateCardCounts(countsToUpdate); 
        } catch (error) {
            console.error('Failed to save card pool after adding cards:', error);
            // è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼ã ãŒã€ã‚¹ãƒˆã‚¢ã¯æ›´æ–°ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®ã¿
        }
    },

    // ğŸ’¡ å®Ÿè£…3: ã‚«ãƒ¼ãƒ‰æšæ•°ã‚’è¨­å®šã—ã€DBã«ä¿å­˜ã™ã‚‹ï¼ˆå£²å´ã‚„ç·¨é›†ç”¨ï¼‰
    setCardCount: async (cardId, count) => {
        // count ã¯ 0 ä»¥ä¸Šã«åˆ¶é™
        const newCount = Math.max(0, count);

        set(state => {
            const newOwnedCards = new Map(state.ownedCards);
            let newTotal = state.totalOwnedCards;

            // å¤ã„æšæ•°ã‚’å–å¾—
            const oldCount = newOwnedCards.get(cardId) || 0;
            
            // ç·æšæ•°ã‚’æ›´æ–°
            newTotal = newTotal - oldCount + newCount;

            if (newCount > 0) {
                newOwnedCards.set(cardId, newCount);
            } else {
                newOwnedCards.delete(cardId);
            }

            return { 
                ownedCards: newOwnedCards, 
                totalOwnedCards: newTotal 
            };
        });

        // ğŸ› ï¸ DBã¸å¤‰æ›´ã‚’ä¿å­˜ (éåŒæœŸ)
        try {
            // 1æšã®æ›´æ–°ã‚‚ bulkUpdateCardCounts ã§å‡¦ç†å¯èƒ½
            const countsToUpdate = new Map<string, number>([[cardId, newCount]]);
            await cardPoolService.bulkUpdateCardCounts(countsToUpdate); 
        } catch (error) {
            console.error('Failed to save card pool after setting count:', error);
        }
    },

    // ğŸ’¡ å®Ÿè£…4: ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«å…¨ä½“ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
    resetPool: async () => {
        // DBã‹ã‚‰ã‚‚å‰Šé™¤ã™ã‚‹
        // ğŸ› ï¸ DBãƒªã‚»ãƒƒãƒˆã‚’éåŒæœŸã«ã—ã€ç¢ºå®Ÿã«å®Œäº†ã‚’å¾…ã¤
        await cardPoolService.bulkUpdateCardCounts(new Map()); // ç©ºã®Mapã§DBã‚’ãƒªã‚»ãƒƒãƒˆ
        set(initialState);
        console.log("Card pool reset completed.");
    },

    // --------------------------------------------------
    // ğŸ’¡ ZIPã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    // --------------------------------------------------

    importCardPool: async (importedOwnedCards) => {
        // 1. DBã‚’å®Œå…¨ã«ä¸Šæ›¸ã (ã‚¯ãƒªã‚¢ã—ã¦ã‹ã‚‰æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆ)
        try {
            // ğŸ’¡ æ—¢å­˜ã® bulkUpdateCardCounts ã‚’å†åˆ©ç”¨ã—ã€ç©ºã®Mapã§ã‚¯ãƒªã‚¢å¾Œã€æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            await cardPoolService.bulkUpdateCardCounts(new Map()); // DBã‚’ã‚¯ãƒªã‚¢
            await cardPoolService.bulkUpdateCardCounts(importedOwnedCards); // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
        } catch (error) {
            console.error("Failed to overwrite card pool in DB:", error);
            throw new Error("ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã®DBä¸Šæ›¸ãã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        }
        
        // 2. Zustandã‚¹ãƒˆã‚¢ã®çŠ¶æ…‹ã‚’æ›´æ–°
        let newTotal = 0;
        importedOwnedCards.forEach(count => {
            newTotal += count;
        });

        set({
            ownedCards: importedOwnedCards, 
            totalOwnedCards: newTotal
        });
        console.log(`âœ… Card pool imported. Total: ${newTotal} cards.`);
    },
}));