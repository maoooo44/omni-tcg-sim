// src/stores/deckStore.ts (ä¿®æ­£ãƒ»å…¨æ–‡)

import { create } from 'zustand';
// import { useShallow } from 'zustand/react/shallow'; 
import type { Deck } from '../models/deck';
import { v4 as uuidv4 } from 'uuid'; // generateUUIDã®ä»£ã‚ã‚Šã«v4ã‚’ç›´æ¥ä½¿ç”¨
import { deckService } from '../services/deck-logic/deckService';
import { useCardPoolStore } from './cardPoolStore'; 

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ç©ºãƒ‡ãƒƒã‚­ã‚’ç”Ÿæˆã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ï¼ˆã‚¹ãƒˆã‚¢å†…éƒ¨ã§ä½¿ç”¨ï¼‰
const createDefaultDeck = (id?: string): Deck => ({
    deckId: id || uuidv4(), 
    name: 'æ–°è¦ãƒ‡ãƒƒã‚­',
    description: '',
    mainDeck: new Map(), // Map<cardId, count>
    sideDeck: new Map(),
    extraDeck: new Map(),
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    hasUnownedCards: false, 
});

/**
 * ãƒ‡ãƒƒã‚­å…¨ä½“ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€å¿…è¦ãªæšæ•°ãŒæ‰€æœ‰æšæ•°ã‚’è¶…ãˆã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã€‚
 * @param deck ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã®ãƒ‡ãƒƒã‚­
 * @returns boolean ãƒ‡ãƒƒã‚­ã«æœªæ‰€æœ‰ã‚«ãƒ¼ãƒ‰ï¼ˆä¸è¶³æšæ•°ï¼‰ãŒå«ã¾ã‚Œã¦ã„ã‚Œã° true
 */
const checkUnownedCards = (deck: Deck): boolean => {
    // ğŸ’¡ CardPoolStore ã®ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¸€æ™‚çš„ã«å–å¾—
    const ownedCards = useCardPoolStore.getState().ownedCards;

    // å…¨ã¦ã®ã‚«ãƒ¼ãƒ‰ã¨ãã®å¿…è¦æšæ•°ã‚’ãƒã‚§ãƒƒã‚¯
    const allDeckCardEntries = [
        ...deck.mainDeck.entries(),
        ...deck.sideDeck.entries(),
        ...deck.extraDeck.entries(),
    ];

    for (const [cardId, requiredCount] of allDeckCardEntries) {
        // æ‰€æŒæšæ•°ãŒä¸è¶³ã—ã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ãŒ1æšã§ã‚‚ã‚ã‚Œã° true ã‚’è¿”ã™
        if (requiredCount > 0 && (ownedCards.get(cardId) || 0) < requiredCount) {
            return true;
        }
    }
    return false;
};

// ğŸ“Œ ä¿®æ­£: DeckState ã«ãƒ‡ãƒƒã‚­ä¸€è¦§ç®¡ç†ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
export interface DeckState {
    // ğŸ’¡ æ—¢å­˜ã®ç·¨é›†ä¸­ã®ãƒ‡ãƒƒã‚­çŠ¶æ…‹
    currentDeck: Deck; 
    // ğŸ’¡ æ–°è¦è¿½åŠ : DBã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå…¨ã¦ã®ãƒ‡ãƒƒã‚­ã®ãƒªã‚¹ãƒˆ
    decks: Map<string, Deck>; 
    isLoading: boolean;
    
    // --- ãƒ‡ãƒƒã‚­ä¸€è¦§ç®¡ç†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
    loadDecks: () => Promise<void>;
    getDeckById: (deckId: string) => Deck | undefined;
    
    // --- ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
    // ğŸ’¡ newDeck (ä½œæˆ) ã®å®Ÿè£…ã‚’ã€createDeck (DBé€£æº) ã«ä¸€æœ¬åŒ–
    createDeck: () => Promise<string>; 
    // ğŸ’¡ IDã‚’æŒ‡å®šã—ã¦ç·¨é›†å¯¾è±¡ã®ãƒ‡ãƒƒã‚­ã‚’èª­ã¿è¾¼ã‚€
    loadDeckForEdit: (deckId: string) => void;
    
    // ğŸ’¡ æ—¢å­˜ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ä¿®æ­£/çµ±åˆ
    updateDeckInfo: (info: Partial<Omit<Deck, 'mainDeck' | 'sideDeck' | 'extraDeck'>>) => void;
    updateCardCount: (zone: keyof Pick<Deck, 'mainDeck' | 'sideDeck' | 'extraDeck'>, cardId: string, count: number) => void;
    addCardToDeck: (cardId: string, zone: keyof Pick<Deck, 'mainDeck' | 'sideDeck' | 'extraDeck'>) => void;
    removeCardFromDeck: (cardId: string, zone: keyof Pick<Deck, 'mainDeck' | 'sideDeck' | 'extraDeck'>) => void;
    
    // --- DBé€£æºã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
    saveDeck: () => Promise<void>; 
    deleteDeck: (deckId: string) => Promise<void>;
    // ğŸ’¡ ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    importDecks: (decksToImport: Deck[]) => Promise<{ importedCount: number, renamedCount: number }>;
}

const initialState = {
    // ğŸ’¡ åˆæœŸçŠ¶æ…‹ã§ã¯ç©ºã®ãƒ‡ãƒƒã‚­ãƒªã‚¹ãƒˆã¨ç©ºã®ç·¨é›†ãƒ‡ãƒƒã‚­
    decks: new Map<string, Deck>(),
    currentDeck: createDefaultDeck(),
    isLoading: false,
};

export const useDeckStore = create<DeckState>((set, get) => ({
    ...initialState,
    
    // --- ãƒ‡ãƒƒã‚­ä¸€è¦§ç®¡ç†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè£… ---
    
    /**
     * DBã‹ã‚‰å…¨ã¦ã®ãƒ‡ãƒƒã‚­ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã€ã‚¹ãƒˆã‚¢ã‚’åˆæœŸåŒ–ã™ã‚‹
     */
    loadDecks: async () => {
        set({ isLoading: true });
        try {
            const deckList = await deckService.getAllDecks();
            // é…åˆ—ã‚’Mapã«å¤‰æ›
            const decksMap = new Map(deckList.map(deck => [deck.deckId, deck]));
            
            set({ decks: decksMap });
            console.log(`âœ… [DeckStore] ${deckList.length} decks loaded from DB.`);
        } catch (error) {
            console.error("Failed to load decks:", error);
            set({ decks: new Map() });
        } finally {
            set({ isLoading: false });
        }
    },
    
    /**
     * IDã‹ã‚‰ãƒ‡ãƒƒã‚­æƒ…å ±ã‚’å–å¾—ã™ã‚‹ï¼ˆãƒªã‚¹ãƒˆã‹ã‚‰ï¼‰
     */
    getDeckById: (deckId: string) => {
        return get().decks.get(deckId);
    },
    
    /**
     * æ–°ã—ã„ãƒ‡ãƒƒã‚­ã‚’ä½œæˆã—ã€DBã¨ã‚¹ãƒˆã‚¢ã«ä¿å­˜ã™ã‚‹
     * ğŸ’¡ DBé€£æºã®ãŸã‚ã€createDeckServiceã‚’å‘¼ã³å‡ºã™
     */
    createDeck: async () => {
        const newDeck = createDefaultDeck();
        
        await deckService.createDeck(newDeck);
        
        set(state => {
            const newDecks = new Map(state.decks);
            newDecks.set(newDeck.deckId, newDeck);
            return { decks: newDecks, currentDeck: newDeck };
        });
        
        return newDeck.deckId;
    },
    
    /**
     * IDã‚’æŒ‡å®šã—ã¦ç·¨é›†å¯¾è±¡ã®ãƒ‡ãƒƒã‚­ã‚’ currentDeck ã«èª­ã¿è¾¼ã‚€
     */
    loadDeckForEdit: (deckId) => {
        const deck = get().decks.get(deckId);
        if (deck) {
            // ğŸ’¡ ç·¨é›†ç”¨ã«ã¯ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã‚’ä¸ãˆã‚‹ (Mapã¯å‚ç…§æ¸¡ã—ã«ãªã‚‹ãŸã‚)
            const deckCopy: Deck = {
                ...deck,
                mainDeck: new Map(deck.mainDeck),
                sideDeck: new Map(deck.sideDeck),
                extraDeck: new Map(deck.extraDeck),
            };
            set({ currentDeck: deckCopy });
        } else {
            // è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°æ–°è¦ãƒ‡ãƒƒã‚­ã‚’ä½œæˆ (ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯å¿…è¦ã«å¿œã˜ã¦å¼·åŒ–)
            set({ currentDeck: createDefaultDeck(deckId) });
        }
    },

    // --- æ—¢å­˜ã®ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ (ãƒ­ã‚¸ãƒƒã‚¯ã¯ã»ã¼ç¶­æŒ) ---

    updateDeckInfo: (info) => {
        set(state => ({
            currentDeck: { ...state.currentDeck, ...info },
        }));
    },
    
    updateCardCount: (zone, cardId, count) => {
        set(state => {
            const newMap = new Map(state.currentDeck[zone]);
            if (count > 0) {
                newMap.set(cardId, count);
            } else {
                newMap.delete(cardId);
            }
            
            // ğŸ’¡ ã‚«ãƒ¼ãƒ‰ã‚«ã‚¦ãƒ³ãƒˆãŒå¤‰æ›´ã•ã‚ŒãŸå¾Œã€hasUnownedCardsã‚’æ›´æ–°ã™ã‚‹
            const updatedDeck = {
                ...state.currentDeck,
                [zone]: newMap,
            } as Deck; // å‹æ¨è«–ã‚’åŠ©ã‘ã‚‹

            const hasUnownedCards = checkUnownedCards(updatedDeck);
            
            return {
                currentDeck: {
                    ...updatedDeck,
                    hasUnownedCards: hasUnownedCards, // ğŸ’¡ ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
                }
            };
        });
    },
    
    addCardToDeck: (cardId, zone) => {
        const state = get();
        const currentCount = state.currentDeck[zone].get(cardId) || 0;
        state.updateCardCount(zone, cardId, currentCount + 1);
    },

    removeCardFromDeck: (cardId, zone) => {
        const state = get();
        const currentCount = state.currentDeck[zone].get(cardId) || 0;
        if (currentCount > 0) {
            state.updateCardCount(zone, cardId, currentCount - 1);
        }
    },

    // --- DBé€£æºã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè£… ---

    /**
     * ç·¨é›†ä¸­ã®ãƒ‡ãƒƒã‚­ï¼ˆcurrentDeckï¼‰ã‚’DBã¨ãƒ‡ãƒƒã‚­ä¸€è¦§ã«ä¿å­˜ã™ã‚‹
     */
    saveDeck: async () => {
        const deckToSave = get().currentDeck;

        try {
            // æœ€å¾Œã®ãƒã‚§ãƒƒã‚¯ï¼šä¿å­˜ç›´å‰ã«å†åº¦ãƒã‚§ãƒƒã‚¯
            const finalHasUnownedCards = checkUnownedCards(deckToSave);
            const finalDeckToSave: Deck = { 
                ...deckToSave, 
                hasUnownedCards: finalHasUnownedCards,
                updatedAt: new Date().toISOString(), // æœ€çµ‚æ›´æ–°æ—¥ã‚’æ›´æ–°
            };
            
            // 1. DBã«ä¿å­˜/æ›´æ–°
            await deckService.saveDeck(finalDeckToSave);

            // 2. Zustandã‚¹ãƒˆã‚¢ã®çŠ¶æ…‹ã‚’æ›´æ–°
            set(state => {
                const newDecks = new Map(state.decks);
                newDecks.set(finalDeckToSave.deckId, finalDeckToSave); // ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                
                return {
                    decks: newDecks,
                    currentDeck: finalDeckToSave, // ç·¨é›†ä¸­ã®ãƒ‡ãƒƒã‚­ã‚‚æœ€æ–°ç‰ˆã«æ›´æ–°
                };
            });
            console.log(`Deck ${finalDeckToSave.deckId} saved/updated successfully.`);

        } catch (error) {
            console.error('Failed to save deck:', error);
            throw new Error('ãƒ‡ãƒƒã‚­ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    },
    
    /**
     * IDã‚’æŒ‡å®šã—ã¦ãƒ‡ãƒƒã‚­ã‚’DBã¨ã‚¹ãƒˆã‚¢ã‹ã‚‰å‰Šé™¤ã™ã‚‹
     */
    deleteDeck: async (deckId) => {
        await deckService.deleteDeck(deckId);
        
        set(state => {
            const newDecks = new Map(state.decks);
            newDecks.delete(deckId);
            
            // å‰Šé™¤ã—ãŸã®ãŒç·¨é›†ä¸­ã®ãƒ‡ãƒƒã‚­ã ã£ãŸå ´åˆã€ç·¨é›†çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            const newCurrentDeck = state.currentDeck.deckId === deckId 
                ? createDefaultDeck() 
                : state.currentDeck;

            return { decks: newDecks, currentDeck: newCurrentDeck };
        });
        console.log(`Deck ${deckId} deleted.`);
    },
    
    /**
     * å¤–éƒ¨ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸãƒ‡ãƒƒã‚­ã‚’å‡¦ç†ã—ã€DBã¨ã‚¹ãƒˆã‚¢ã‚’æ›´æ–°ã™ã‚‹
     */
    importDecks: async (decksToImport) => {
        const result = await deckService.importDecks(decksToImport);

        // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã«DBã®å…¨ä»¶ã‚’å†ãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚¹ãƒˆã‚¢ã‚’æœ€æ–°åŒ–
        await get().loadDecks(); 
        
        return result;
    },
}));