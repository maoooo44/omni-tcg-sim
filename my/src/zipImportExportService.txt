// src/services/data-import-export/zipImportExportService.ts

import JSZip from 'jszip';
import { packService } from '../pack-logic/packService';
import { deckService } from '../deck-logic/deckService';
import { useUserDataStore } from '../../stores/userDataStore';
import { useCardPoolStore } from '../../stores/cardPoolStore';
import type { Pack } from '../../models/pack'; // å‹å®šç¾©ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
import type { Deck } from '../../models/deck'; // å‹å®šç¾©ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

/**
 * ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¨ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã€ãŠã‚ˆã³ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã®çµ±åˆã‚’æ‹…ã†ã‚µãƒ¼ãƒ“ã‚¹
 */
export const zipImportExportService = {
    
    // ... collectAllData ã®å®Ÿè£… (å¤‰æ›´ãªã—) ...
    async collectAllData(): Promise<Record<string, any>> {
        const packs = await packService.getAllPacks();
        const decks = await deckService.getAllDecks();
        const userDataState = useUserDataStore.getState();
        const cardPoolState = useCardPoolStore.getState();

        const jsonCompatibleDecks = decks.map(d => ({
            ...d,
            mainDeck: Array.from(d.mainDeck.entries()),
            sideDeck: Array.from(d.sideDeck.entries()),
            extraDeck: Array.from(d.extraDeck.entries()),
        }));
        
        const jsonCompatibleCardPool = {
            ...cardPoolState,
            ownedCards: Array.from(cardPoolState.ownedCards.entries()),
        };

        return {
            packs: packs,
            decks: jsonCompatibleDecks,
            user_data: {
                userData: userDataState,
                cardPool: jsonCompatibleCardPool,
            },
            metadata: { 
                exportedAt: new Date().toISOString(),
                version: "1.0.0" 
            },
        };
    },

    // ... exportDataToZip ã®å®Ÿè£… (å¤‰æ›´ãªã—) ...
    async exportDataToZip(): Promise<Blob> {
        const allData = await this.collectAllData();
        const zip = new JSZip();
        
        zip.file("packs.json", JSON.stringify(allData.packs, null, 2));
        zip.file("decks/decks.json", JSON.stringify(allData.decks, null, 2));
        zip.file("user_data/userData.json", JSON.stringify(allData.user_data.userData, null, 2));
        zip.file("user_data/cardPool.json", JSON.stringify(allData.user_data.cardPool, null, 2));
        zip.file("metadata.json", JSON.stringify(allData.metadata, null, 2));

        const zipBlob = await zip.generateAsync({ type: "blob" });
        return zipBlob;
    },

    // ... importDataFromZip ã®å®Ÿè£… (å¤‰æ›´ãªã—) ...
    async importDataFromZip(zipFile: File): Promise<Record<string, any>> {
        const zip = new JSZip();
        await zip.loadAsync(zipFile);

        const loadedData: Record<string, any> = {};

        const filePromises = [
            zip.file("packs.json")?.async("string").then(content => {
                if (content) loadedData.packs = JSON.parse(content);
            }),
            zip.file("decks/decks.json")?.async("string").then(content => {
                if (content) loadedData.decks = JSON.parse(content);
            }),
            zip.file("user_data/userData.json")?.async("string").then(content => {
                if (content) loadedData.userData = JSON.parse(content);
            }),
            zip.file("user_data/cardPool.json")?.async("string").then(content => {
                if (content) loadedData.cardPool = JSON.parse(content);
            }),
        ];

        await Promise.all(filePromises);

        // ğŸ’¡ Mapæ§‹é€ ã¸ã®å¾©å…ƒå‡¦ç†
        if (loadedData.decks) {
            loadedData.decks = loadedData.decks.map((d: any) => ({
                ...d,
                mainDeck: new Map(d.mainDeck),
                sideDeck: new Map(d.sideDeck),
                extraDeck: new Map(d.extraDeck),
            }));
        }
        
        if (loadedData.cardPool) {
            loadedData.cardPool.ownedCards = new Map(loadedData.cardPool.ownedCards);
        }

        return loadedData;
    },

    // --------------------------------------------------
    // ğŸ’¡ ãƒ‡ãƒ¼ã‚¿çµ±åˆ (ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³) ãƒ­ã‚¸ãƒƒã‚¯
    // --------------------------------------------------

    /**
     * è§£ææ¸ˆã¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã€å„ã‚µãƒ¼ãƒ“ã‚¹/ã‚¹ãƒˆã‚¢ã«æ›¸ãè¾¼ã‚€ã€‚
     * @param importedData - importDataFromZipã®çµæœ (Mapæ§‹é€ ã«å¾©å…ƒæ¸ˆã¿)
     * @returns çµ±åˆçµæœã®ã‚µãƒãƒªãƒ¼
     */
    async integrateImportedData(importedData: Record<string, any>): Promise<string> {
        let summary = "ZIPã‚¤ãƒ³ãƒãƒ¼ãƒˆçµæœ:\n";
        
        // 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ (coins, mode, cheatCount) ã®ä¸Šæ›¸ã
        if (importedData.userData) {
            useUserDataStore.getState().importUserData(importedData.userData);
            summary += "- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿: ä¸Šæ›¸ãå®Œäº†ã€‚\n";
        } else {
             summary += "- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿: ãƒ‡ãƒ¼ã‚¿ãŒZIPã«å­˜åœ¨ã—ã¾ã›ã‚“ã§ã—ãŸã€‚\n";
        }

        // 2. ãƒ‘ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ  (è¡çªå›é¿)
        if (importedData.packs && importedData.packs.length > 0) {
            const result = await packService.importPacks(importedData.packs as Pack[]);
            summary += `- ãƒ‘ãƒƒã‚¯: ${result.importedCount}ä»¶è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚`;
            if (result.skippedIds.length > 0) {
                summary += ` (${result.skippedIds.length}ä»¶ã®IDè¡çªã‚’ã‚¹ã‚­ãƒƒãƒ—ã€‚)\n`;
            } else {
                summary += "\n";
            }
        } else {
            summary += "- ãƒ‘ãƒƒã‚¯: ãƒ‡ãƒ¼ã‚¿ãŒZIPã«å­˜åœ¨ã—ã¾ã›ã‚“ã§ã—ãŸã€‚\n";
        }

        // 3. ãƒ‡ãƒƒã‚­ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ  (IDè¡çªæ™‚ã¯è‡ªå‹•ãƒªãƒãƒ¼ãƒ )
        if (importedData.decks && importedData.decks.length > 0) {
            const result = await deckService.importDecks(importedData.decks as Deck[]);
            summary += `- ãƒ‡ãƒƒã‚­: ${result.importedCount}ä»¶è¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚`;
            if (result.renamedCount > 0) {
                summary += ` (${result.renamedCount}ä»¶ã®IDè¡çªã‚’è‡ªå‹•ãƒªãƒãƒ¼ãƒ ã€‚)\n`;
            } else {
                summary += "\n";
            }
        } else {
            summary += "- ãƒ‡ãƒƒã‚­: ãƒ‡ãƒ¼ã‚¿ãŒZIPã«å­˜åœ¨ã—ã¾ã›ã‚“ã§ã—ãŸã€‚\n";
        }

        // 4. ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«ã®å…¨ä½“ä¸Šæ›¸ã
        if (importedData.cardPool && importedData.cardPool.ownedCards instanceof Map) {
             // CardPoolã‚¹ãƒˆã‚¢ã®importã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯DBä¸Šæ›¸ãã‚‚å«ã‚“ã§ã„ã‚‹
            await useCardPoolStore.getState().importCardPool(importedData.cardPool.ownedCards);
            summary += `- ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«: ${importedData.cardPool.ownedCards.size}ç¨®é¡ã®ã‚«ãƒ¼ãƒ‰ã§å®Œå…¨ã«ä¸Šæ›¸ãã•ã‚Œã¾ã—ãŸã€‚\n`;
        } else {
            summary += "- ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¼ãƒ«: ãƒ‡ãƒ¼ã‚¿ãŒZIPã«å­˜åœ¨ã—ã¾ã›ã‚“ã§ã—ãŸã€‚\n";
        }

        return summary;
    },
    
    /**
     * ğŸ’¡ çµ±åˆã•ã‚ŒãŸã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ãƒ­ãƒ¼ã®å…¬é–‹é–¢æ•°
     */
    exportData: async () => {
        return zipImportExportService.exportDataToZip();
    },

    importData: async (zipFile: File) => {
        const loadedData = await zipImportExportService.importDataFromZip(zipFile);
        const resultSummary = await zipImportExportService.integrateImportedData(loadedData);
        return resultSummary;
    }
};